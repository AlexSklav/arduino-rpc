# coding: utf-8
import sys
from typing import Union

from clang_helpers import open_cpp_source, extract_class_declarations
from clang_helpers.data_frame import get_clang_methods_frame
from path_helpers import path
import pandas as pd

from .rpc_data_frame import get_struct_sig_info_frame

# Generic messages to prepend to generated source files.
C_GENERATED_WARNING_MESSAGE = '''
/* #########################################################################
 * [{}] THIS FILE IS AUTOGENERATED - DO NOT EDIT!
 * ######################################################################### */
'''

PYTHON_GENERATED_WARNING_MESSAGE = '''
# ############################################################################
# [{}] THIS FILE IS AUTOGENERATED - DO NOT EDIT!
# ############################################################################
'''


def get_multilevel_method_sig_frame(cpp_header: Union[str, list],
                                    class_name: Union[str, list],
                                    *args, **kwargs) -> pd.DataFrame:
    """
    Given one or more C++ header paths, each with a corresponding C++ class
    name, return a `pandas.DataFrame` with one row per method argument.


    Notes
    -----

     - Each row in the frame has a `class_name` (including namespace) and
       `method_name`, indicating the specific method that corresponds to the
       row argument.
     - Template classes are supported.  For example, the class defined as:

           class ClassName<typename Parameter1, typename Parameter2> {...};

       is referenced in the frame with the `class_name` of
       `ClassName<Parameter1, Parameter2>`.
     - Only rows corresponding to the *last* occurrence of each method name are
       included in the data frame.  The order is determined by the order of the
       headers and classes provided in the `cpp_header` argument and the
       `class_name` argument, respectively.
    """
    if isinstance(cpp_header, str):
        cpp_header = [cpp_header]
    if isinstance(class_name, str):
        class_name = [class_name]
    assert (len(cpp_header) == len(class_name))

    # Default to 16-bit pointer size (i.e., assume 8-bit AVR Arduino by
    # default).
    pointer_width = kwargs.pop('pointer_width', 16)

    frames = []
    for header, class_ in zip(cpp_header, class_name):
        try:
            root = open_cpp_source(str(header), *args, **kwargs)
        except Exception as e:
            print(f'[Warning] Failed to  read {header}')
            # print(e)
            # from IPython import embed
            # embed()
            # raise e
        class_declarations = extract_class_declarations(root)
        node_class = class_declarations[class_]
        from pprint import pprint
        # for key, value in class_declarations.items():
        #     if key != class_:
        #         from clang.cindex import CursorKind
        #         print([m.displayname for m in value.get_children() if m.kind == CursorKind.CXX_METHOD])

        # ret = get_clang_methods_frame(value, std_types=True)
        # if ret is not None:
        #     pprint(ret.method_name.values)
        df_sig_info = get_clang_methods_frame(node_class, std_types=True)
        frame = get_struct_sig_info_frame(df_sig_info, pointer_width=pointer_width)
        frame['header_name'] = path(header).name
        frame['class_name'] = class_
        frames.append(frame)

    # Method names may occur in multiple headers.  Only process the last occurrence in the table for each method.
    if len(frames) > 1:
        method_names = [frame.method_name.unique() for frame in frames]
        unique_names = pd.DataFrame(method_names).stack().to_frame('method_name').groupby('method_name').nth(-1)
        unique_frames = []
        for i in unique_names.index.unique(level=0):
            frame = frames[i]
            unique_frames.append(frame.merge(unique_names.loc[i], how='right'))

        df_unique_methods = pd.concat(unique_frames, ignore_index=True)
    else:
        df_unique_methods = pd.concat(frames, ignore_index=True)

    class_i = df_unique_methods.class_name.unique()
    # **N.B.,** Allocate 256 command slots for each class.
    df_unique_methods.method_i += 0xFF * df_unique_methods.class_name.map(lambda x: (x == class_i).argmax())
    return df_unique_methods


def write_code(cpp_header: list, class_name: list, out_file: Union[str, path],
               f_get_code: callable, *args, **kwargs) -> None:
    """
    Provided a list of C++ header files and a list of class names to discover
    in the corresponding files, write the result of the provided `f_get_code`
    function to the supplied output file path.

    Method signatures are found using the `get_multilevel_method_sig_frame`
    function (see function docstring for more details).

    Note that for methods with the same name, only the last discovered method
    (according to the order in the `class_name` list) will be included in the

    Arguments
    ---------

     - `cpp_header`: A single filepath to a C++ header, or a list of header
       paths.
     - `class_name`: A single C++ class name (including namespace), or a list
       of class names.
       * Template classes are supported.  For example, the class defined as:

             class ClassName<typename Parameter1, typename Parameter2> {...};

         is referenced in the frame with the `class_name` of
         `ClassName<Parameter1,Parameter2>`.
    """
    methods_filter = kwargs.pop('methods_filter', lambda x: x)

    # Apply filter to methods (accepts all rows by default).
    df_methods = methods_filter(get_multilevel_method_sig_frame(cpp_header, class_name, *args, **kwargs))
    # print(df_methods[['header_name', 'method_name']])
    if out_file == '-':
        # Write code to `stdout`.
        print(f_get_code(df_methods), file=sys.stdout)
    else:
        with open(out_file, 'w') as output:
            output.write(f_get_code(df_methods))
